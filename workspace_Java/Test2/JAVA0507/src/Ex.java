
public class Ex {

	public static void main(String[] args) {
		/*
		 *  배열(Array) : 같은 타입 데이터 여러개를 하나의 묶음(변수)으로 다루는 메모리 공간
		 *  0. 일차원 배열과 다차원 배열로 구분됨
		 *  1. 같은 데이터타입만 저장 가능
		 *  2. 기본 데이터타입과 참조 데이터타입을 모두 배열로 관리 가능
		 *  3. 배열을 사용하기 위해서는 배열 선언, 생성, 초기화가 필요하다!
		 *     (단, 배열 초기화를 생략할 경우 기본값으로 자동 초기화 됨)
		 *  4. 배열명(변수명)을 사용하여 데이터 관리
		 *     (=> 배열변수는 참조형 변수로 취급되며, 실제 배열 공간의 주소값이 저장됨)
		 *  5. 배열은 인덱스(첨자)를 사용하여 배열의 각 요소에 접근
		 *     (인덱스는 0 부터 시작하여 배열크기-1 까지 자동으로 부여됨)
		 *  6. 배열 크기는 변수명.length 의 형태로 얻어올 수 있음
		 *  7. 한 번 생성된 배열은 크기 변경 불가
		 *     (크기 변경 대신 새로운 배열을 생성하여 이동시켜야 함)
		 *  
		 *  < 배열 선언 기본 문법 >
		 *  데이터타입[] 변수명;
		 *  => Stack 이라는 메모리 공간에 int형 배열 변수 a 를 선언
		 *     (단, 아직 데이터를 저장할 수 있는 실제 공간은 생성되지 않은 상태)
		 *  
		 *  < 배열 생성 기본 문법 >
		 *  변수명 = new 데이터타입[배열크기];
		 *  => new 키워드를 사용하여 Heap 공간에 실제 데이터 저장 공간 생성
		 *  => new 키워드 뒤의 데이터타입은 배열 선언에 명시했던 데이터타입을 다시 명시
		 *  => 배열크기는 인덱스(첨자)라고도 하며 지정된 크기만큼 데이터 저장공간이 생성됨
		 *     (이 때, 각 저장 공간의 인덱스 번호가 0 ~ 배열크기-1 번까지 자동으로 부여됨)
		 *     
		 *  < 배열 접근 및 초기화 기본 문법 >
		 *  배열 접근 : 변수명[인덱스] 
		 *  배열 초기화 : 변수명 [인덱스] = 데이터
		 *  => 인덱스는 자동으로 생성된 번호를 사용
		 *  => 잘못된 인덱스(없는 번호)를 지정할 경우 오류(ArrayIndexOutOfBoundsException) 발생
		 *  
		 *  < 배열 선언 및 생성 동시에 수행하는 문법 >
		 *  데이터타입[] 변수명 = new 데이터타입[배열크기];
		 *  
		 *  < 배열 전체에 접근하는 반복문 공식 >
		 *  - 배열의 length 속성을 활용하면 배열 크기에 따라 동적으로 변하는 반복문 작성 가능
		 *    => 반복문 초기값을 0부터 시작하여 조건식을 배열크기-1 까지 반복해야하므로
		 *       배열크기-1 을 '제어변수가 배열크기보다 작을 동안' 으로 바꾸면 됨 
		 *  for(int i = 0; i < 배열명.length; i++) {}
		 */
		
		// int형 데이터를 저장할 배열 a 선언
//		int a; // 일반 변수
		int[] a; // 참조형 변수(주소값을 저장할 수 있는 변수)
		
		// int형 데이터 저장 가능한 배열을 생성
		a = new int[3]; // 정수(int형) 데이터 저장공간 3개를 생성하여 주소값을 a에 저장
//		a = null; // 주소값이 없을 경우 null 이라는 특수한 값을 사용(참조 주소가 없다는 의미)
		
		
		// 배열 크기 출력
		System.out.println("배열 a 의 크기 : " + a.length);
		// => a 라는 참조형 변수가 가리키는 주소 공간을 찾아가서 length 속성에 해당하는 값 리턴
		
			
		// int형 데이터를 배열에 저장
//		a = 10; // 일반 변수에 데이터 초기화하는 방법
		a[0] = 10; // 배열에 데이터 초기화 방법(배열 a의 0번 인덱스에 정수 10 저장)
		a[1] = 20; // 배열 a의 1번 인덱스에 정수 20 저장
		System.out.println("배열 a의 0번 인덱스 데이터 : " + a[0]);
		System.out.println("배열 a의 1번 인덱스 데이터 : " + a[1]);
		
		a[2] = 30;
		System.out.println("배열 a의 2번 인덱스 데이터 : " + a[2]);
		
		
//		System.out.println(a); // 이상한 값이 출력됨(참조변수에 저장된 주소값)
		
		System.out.println("-----------------");
		
		// int형 배열 변수 b 를 선언 및 5개의 공간 생성
		// 0번인덱스 : 100, 1번인덱스 : 200, 2번인덱스 : 300 으로 초기화
		int[] b = new int[5];
		
		b[0] = 100;
		b[1] = 200;
		b[2] = 300;
		
		System.out.println(b[0]);
		System.out.println(b[1]);
		System.out.println(b[2]);
		System.out.println(b[3]); // 초기화하지 않은 배열의 인덱스 공간에는 기본값 자동 초기화
		System.out.println(b[4]); // 즉, int형 배열이므로 자동으로 0으로 초기화 되어있음
		
//		System.out.println(b[5]); // 존재하지 않는 인덱스 참조했기 때문에 오류 발생
		                          // => 문법적으로 올바른 문법이므로 컴파일에러 발생하지 않는다!
		                          // => 실행 시 5번 인덱스가 존재하지 않을 때 오류 검출됨!
		/*
		 * Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 5
	     * at Ex.main(Ex.java:89)
	     * => 배열 인덱스 5 에 대한 접근 오류가 발생했으며
	     *    오류 발생 코드 위치는 Ex.java 파일의 89번 라인
		 */
		
		
		System.out.println("------------");
		
		// 반복문을 사용한 배열 접근
		for(int i = 0; i < b.length; i++) {
			System.out.println(b[i]); // i가 0 ~ 4까지 1씩 증가할 동안 인덱스번호로 사용됨
		}
		
		
		// 주의! 기본형 변수(로컬(지역) 변수)는 반드시 초기화 필요
		int c;
//		System.out.println(c); // 오류 발생! => 초기화되지 않은 상태에서 사용 불가!
		
		
		// 주의사항!
		// C언어 계열 등에서는 배열 선언 시 변수명 뒤에 [] 표시를 붙이고
		// 자바에서도 사용 가능한 문법이지만 가급적 변수명 앞 데이터타입 뒤에 [] 표시 붙이기!
		int arr1, arr2[]; // arr1 은 기본형 변수이고, arr2 만 배열이 된다.
		int[] arr3, arr4; // arr3, arr4 모두 배열로 선언됨 => 자바에서 권장하는 문법!
		
		
		
		
	}

}
























